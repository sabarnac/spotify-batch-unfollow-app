{"version":3,"file":"static/js/807.250209d9.chunk.js","mappings":"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","sources":["util/index.ts","util/use-call.ts","util/use-stream-call.ts","client/spotify/util/response-parser.ts","util/retry-fetch.ts","client/spotify/util/send-request.ts","client/spotify/api/get-user-artist-follows.ts","client/spotify/api/get-all-user-artist-follows.ts","client/spotify/api/get-user-show-follows.ts","client/spotify/api/get-all-user-show-follows.ts","client/spotify/api/get-current-user.ts","util/array-chunk.ts","client/spotify/api/unfollow-artists.ts","client/spotify/api/unfollow-artists-chunked.ts","client/spotify/api/unfollow-shows.ts","client/spotify/api/unfollow-shows-chunked.ts","client/spotify/api/unfollow-users.ts","client/spotify/api/unfollow-users-chunked.ts","client/spotify/api/get-user-album-follows.ts","client/spotify/api/get-all-user-album-follows.ts","client/spotify/api/unfollow-albums.ts","client/spotify/api/unfollow-albums-chunked.ts","client/spotify/api/get-user-playlist-follows.ts","client/spotify/api/get-all-user-playlist-follows.ts","client/spotify/api/unfollow-playlist.ts","client/spotify/api/unfollow-playliss-chunked.ts","client/spotify/index.ts","app/spotify-app/user/UserInfo.tsx"],"sourcesContent":["export const isNullOrUndefined = (value: unknown): value is null | undefined => value === null || value === undefined;\n","import { useEffect, useState } from \"react\";\n\nimport { FetchError } from \"./retry-fetch\";\n\ninterface Function<A extends any[], R> {\n  (...args: A): Promise<R>;\n}\n\ntype UseCallResult<R> = [R | undefined, boolean, Error | undefined];\n\nconst useCall = <A extends any[], R>(\n  apiCall: Function<A, R>,\n  runNow: boolean,\n  ...apiArguments: A\n): UseCallResult<R> => {\n  const [result, setResult] = useState<R>();\n  const [error, setError] = useState<Error>();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!runNow) {\n      return;\n    }\n\n    setLoading(true);\n    setResult(undefined);\n    setError(undefined);\n\n    let abort: boolean = false;\n    (async () => {\n      try {\n        const callResult = await apiCall(...apiArguments);\n        if (!abort) {\n          setResult(callResult);\n        }\n\n        setLoading(false);\n      } catch (error) {\n        const errorObj = error as FetchError;\n        if (errorObj.name !== \"AbortError\" && !abort) {\n          setError(errorObj);\n        }\n\n        setLoading(false);\n      }\n    })();\n\n    return () => {\n      abort = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apiCall, runNow, ...apiArguments]);\n\n  return [result, loading, error];\n};\n\nexport default useCall;\n","import { useEffect, useState } from \"react\";\n\nimport { FetchError } from \"./retry-fetch\";\n\ninterface Generator<A extends any[], T, TReturn = any, TNext = unknown> {\n  (...args: A): AsyncGenerator<T, TReturn, TNext>;\n}\n\nexport type UseCallResult<R> = [R[], boolean, Error | undefined];\n\nconst useStreamCall = <A extends any[], R>(\n  apiCall: Generator<A, R>,\n  runNow: boolean,\n  ...apiArguments: A\n): UseCallResult<R> => {\n  const [result, setResult] = useState<R[]>([]);\n  const [error, setError] = useState<Error>();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!runNow) {\n      return;\n    }\n\n    setLoading(true);\n    setResult([]);\n    setError(undefined);\n\n    let abort: boolean = false;\n    (async () => {\n      try {\n        for await (const newResult of apiCall(...apiArguments)) {\n          setLoading(true);\n\n          if (abort) {\n            break;\n          }\n\n          setResult((oldResult) => [...oldResult, newResult]);\n        }\n\n        setLoading(false);\n      } catch (error) {\n        const errorObj = error as FetchError;\n        if (errorObj.name !== \"AbortError\" && !abort) {\n          setError(errorObj);\n        }\n\n        setLoading(false);\n      }\n    })();\n\n    return () => {\n      abort = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apiCall, runNow, ...apiArguments]);\n\n  return [result, loading, error];\n};\n\nexport default useStreamCall;\n","export const getJsonResponse = <T>(response: Response): Promise<T> => response.json();\n\nexport const getTextResponse = (response: Response): Promise<string> => response.text();\n","/**\n * Class for describing a fetch error details.\n */\nexport class FetchError extends Error {\n  private _status: number;\n  private _body: string;\n  private _headers: Headers;\n\n  constructor(status: number, body: string, headers: Headers) {\n    super(`Error has occurred performing the request due to error: ${body} [Status Code: ${status}]`);\n    this._status = status;\n    this._body = body;\n    this._headers = headers;\n  }\n\n  /**\n   * Get the status code of the error response.\n   */\n  public get status(): number {\n    return this._status;\n  }\n\n  /**\n   * Get the body of the error response.\n   */\n  public get body(): string {\n    return this._body;\n  }\n\n  /**\n   * Get the headers of the error response.\n   * @return {Headers}\n   */\n  public get headers(): Headers {\n    return this._headers;\n  }\n}\n\ninterface CountInfo {\n  attemptCount: number;\n  maxAttemptCount: number;\n}\n\n/**\n * Perform a fetch with a retry mechanism.\n * @param url The URL to fetch.\n * @param requestContext Context information for the request.\n * @param retryableErrorCodes Error codes to retry on.\n *\n * @returns The fetch result.\n * @throws {Error} The error response of the fetch.\n */\nconst retryFetch = async (\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n): Promise<Response> =>\n  new Promise(async (resolve, reject): Promise<void> => {\n    const countInfo: CountInfo = {\n      attemptCount: 0,\n      maxAttemptCount: 3,\n    };\n\n    handleFetchResponse(\n      resolve,\n      reject,\n      await fetch(url, requestContext),\n      countInfo,\n      url,\n      requestContext,\n      retryableErrorCodes,\n    );\n  });\n\nconst handleFetchResponse = async (\n  resolve: Function,\n  reject: Function,\n  response: Response,\n  countInfo: CountInfo,\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n) => {\n  if (response.ok) {\n    resolve(response);\n  } else if (\n    countInfo.attemptCount < countInfo.maxAttemptCount &&\n    isRetryableCode(response.status, retryableErrorCodes)\n  ) {\n    countInfo.attemptCount++;\n    performFetch(resolve, reject, response, countInfo, url, requestContext, retryableErrorCodes);\n  } else {\n    reject(new FetchError(response.status, (await response.json()).error.message, response.headers));\n  }\n};\n\nconst getNextRetryTime = (response: Response, countInfo: CountInfo) => {\n  const nextRetryTime: string = response.headers.get(\"Retry-After\") || \"0\";\n  return Math.max(Math.pow(2, countInfo.attemptCount - 1) * 1000, Number(nextRetryTime));\n};\n\nconst performFetch = (\n  resolve: Function,\n  reject: Function,\n  priorResponse: Response,\n  countInfo: CountInfo,\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n) => {\n  setTimeout(async () => {\n    let response: Response = await fetch(url, requestContext);\n    handleFetchResponse(resolve, reject, response, countInfo, url, requestContext, retryableErrorCodes);\n  }, getNextRetryTime(priorResponse, countInfo));\n};\n\nconst isRetryableCode = (code: number, retryableErrorCodes?: number[]) =>\n  code >= 500 || (retryableErrorCodes && retryableErrorCodes.indexOf(code) >= 0);\n\nexport default retryFetch;\n","import { isNullOrUndefined } from \"../../../util\";\nimport retryFetch, { FetchError } from \"../../../util/retry-fetch\";\nimport config, { SPOTIFY_API_URL } from \"../api/config\";\n\ntype RequestPathParams = (string | number)[];\ntype RequestQueryParams = Record<string, string | number | null | undefined>;\n\nconst createQueryPath = (queryObj?: RequestQueryParams): string =>\n  queryObj\n    ? \"?\" +\n      Object.keys(queryObj)\n        .filter((queryKey: string) => !isNullOrUndefined(queryObj[queryKey]))\n        .map((queryKey: string) => `${queryKey}=${encodeURIComponent(queryObj[queryKey]!)}`)\n        .join(\"&\")\n    : \"\";\n\nconst createRequestContext = (body?: BodyInit | null, headers?: HeadersInit, method?: string): RequestInit => ({\n  headers: {\n    Authorization: `Bearer ${config.userToken}`,\n    ...headers,\n  },\n  body,\n  method,\n});\n\nconst sendRequest = async (\n  pathParams: RequestPathParams,\n  queryParams?: RequestQueryParams,\n  body?: BodyInit | null,\n  headers?: HeadersInit,\n  method?: string,\n): Promise<Response> => {\n  const requestPath: string = [SPOTIFY_API_URL, ...pathParams].join(\"/\") + \"/\";\n\n  const queryPath: string = createQueryPath(queryParams);\n\n  return retryFetch(requestPath + queryPath, createRequestContext(body, headers, method), [429]).catch(\n    (error: FetchError): Response => {\n      if (error.status !== 401) {\n        throw error;\n      } else {\n        config.resetToken();\n        throw error;\n      }\n    },\n  );\n};\nexport default sendRequest;\n","import { UserFollowsResponse } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserArtistsFollows = async (type: \"artist\" | \"user\", limit: number, after?: string) => {\n  const results = await getJsonResponse<UserFollowsResponse>(\n    await sendRequest([\"me\", \"following\"], {\n      type,\n      limit,\n      after,\n    }),\n  );\n  return type === \"artist\" ? results.artists : results.users;\n};\n\nexport default getUserArtistsFollows;\n","import { isNullOrUndefined } from \"../../../util\";\nimport { Artist, FollowedArtistsList, FollowedUser, FollowedUsersList, UserInfo } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getUserArtistFollows from \"./get-user-artist-follows\";\n\nconst isUserInfo = (item: Artist | UserInfo): item is UserInfo => item.type === \"user\";\n\nconst getAllUserArtistFollows = async function* (type: \"artist\" | \"user\") {\n  let after = undefined;\n\n  do {\n    const results: FollowedArtistsList | FollowedUsersList = await getUserArtistFollows(type, BATCH_SIZE, after);\n\n    yield results.items.map((item) =>\n      !isUserInfo(item) ? item : ({ ...item, name: item.display_name } as FollowedUser),\n    );\n\n    after = results.cursors.after;\n  } while (!isNullOrUndefined(after));\n};\n\nexport default getAllUserArtistFollows;\n","import { ShowFollowsResponse } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserShowFollows = async (limit: number, offset?: number) =>\n  await getJsonResponse<ShowFollowsResponse>(\n    await sendRequest([\"me\", \"shows\"], {\n      limit,\n      offset,\n    }),\n  );\n\nexport default getUserShowFollows;\n","import { isNullOrUndefined } from \"../../../util\";\nimport { FollowedShowsList } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getUserShowFollows from \"./get-user-show-follows\";\n\nconst getAllUserShowFollows = async function* () {\n  let offset = undefined;\n\n  do {\n    const results: FollowedShowsList = await getUserShowFollows(BATCH_SIZE, offset);\n    yield results.items.map(({ show }) => show);\n\n    offset = results.offset + results.limit;\n    if (offset >= results.total) {\n      offset = undefined;\n    }\n  } while (!isNullOrUndefined(offset));\n};\n\nexport default getAllUserShowFollows;\n","import { UserInfo } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getCurrentUser = async () => getJsonResponse<UserInfo>(await sendRequest([\"me\"]));\n\nexport default getCurrentUser;\n","const arrayChunk = <T>(array: T[], size: number): T[][] => {\n  let chunks = [];\n\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, Math.min(array.length, i + size)));\n  }\n\n  return chunks;\n};\n\nexport default arrayChunk;\n","import { Artist } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowArtists = async (artists: Artist[]) =>\n  await sendRequest(\n    [\"me\", \"following\"],\n    {\n      type: \"artist\",\n      ids: artists.map((artist: Artist): string => artist.id).join(\",\"),\n    },\n    null,\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowArtists;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { Artist, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowArtists from \"./unfollow-artists\";\n\nconst unfollowArtistsChunked = async function* (artists: Artist[]) {\n  for (const chunkedArtists of arrayChunk(artists, BATCH_SIZE)) {\n    try {\n      await unfollowArtists(chunkedArtists);\n      yield {\n        succeeded: chunkedArtists,\n      } as UnfollowChunkedSuccessResult<Artist>;\n    } catch (error) {\n      yield {\n        failed: chunkedArtists,\n        error: error,\n      } as UnfollowChunkedFailureResult<Artist>;\n    }\n  }\n};\n\nexport default unfollowArtistsChunked;\n","import { Show } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowShows = async (shows: Show[]) =>\n  await sendRequest(\n    [\"me\", \"shows\"],\n    {\n      ids: shows.map((show: Show): string => show.id).join(\",\"),\n    },\n    null,\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowShows;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { Show, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowShows from \"./unfollow-shows\";\n\nconst unfollowShowsChunked = async function* (shows: Show[]) {\n  for (const chunkedShows of arrayChunk(shows, BATCH_SIZE)) {\n    try {\n      await unfollowShows(chunkedShows);\n      yield {\n        succeeded: chunkedShows,\n      } as UnfollowChunkedSuccessResult<Show>;\n    } catch (error) {\n      yield {\n        failed: chunkedShows,\n        error: error,\n      } as UnfollowChunkedFailureResult<Show>;\n    }\n  }\n};\n\nexport default unfollowShowsChunked;\n","import { FollowedUser } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowUsers = async (users: FollowedUser[]) =>\n  await sendRequest(\n    [\"me\", \"following\"],\n    {\n      type: \"user\",\n      ids: users.map((user: FollowedUser): string => user.id).join(\",\"),\n    },\n    null,\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowUsers;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { FollowedUser, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowUsers from \"./unfollow-users\";\n\nconst unfollowUsersChunked = async function* (users: FollowedUser[]) {\n  for (const chunkedUsers of arrayChunk(users, BATCH_SIZE)) {\n    try {\n      await unfollowUsers(chunkedUsers);\n      yield {\n        succeeded: chunkedUsers,\n      } as UnfollowChunkedSuccessResult<FollowedUser>;\n    } catch (error) {\n      yield {\n        failed: chunkedUsers,\n        error: error,\n      } as UnfollowChunkedFailureResult<FollowedUser>;\n    }\n  }\n};\n\nexport default unfollowUsersChunked;\n","import { AlbumFollowsResponse } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserAlbumFollows = async (limit: number, offset?: number) =>\n  await getJsonResponse<AlbumFollowsResponse>(\n    await sendRequest([\"me\", \"albums\"], {\n      limit,\n      offset,\n    }),\n  );\n\nexport default getUserAlbumFollows;\n","import { isNullOrUndefined } from \"../../../util\";\nimport { FollowedAlbumsList } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getUserAlbumFollows from \"./get-user-album-follows\";\nconst getAllUserAlbumFollows = async function* () {\n  let offset = undefined;\n\n  do {\n    const results: FollowedAlbumsList = await getUserAlbumFollows(BATCH_SIZE, offset);\n    yield results.items.map(({ album }) => album);\n\n    offset = results.offset + results.limit;\n    if (offset >= results.total) {\n      offset = undefined;\n    }\n  } while (!isNullOrUndefined(offset));\n};\n\nexport default getAllUserAlbumFollows;\n","import { Album } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowAlbums = async (albums: Album[]) =>\n  await sendRequest(\n    [\"me\", \"albums\"],\n    {\n      ids: albums.map((album: Album): string => album.id).join(\",\"),\n    },\n    null,\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowAlbums;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { Album, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowAlbums from \"./unfollow-albums\";\n\nconst unfollowAlbumsChunked = async function* (albums: Album[]) {\n  for (const chunkedAlbums of arrayChunk(albums, BATCH_SIZE)) {\n    try {\n      await unfollowAlbums(chunkedAlbums);\n      yield {\n        succeeded: chunkedAlbums,\n      } as UnfollowChunkedSuccessResult<Album>;\n    } catch (error) {\n      yield {\n        failed: chunkedAlbums,\n        error: error,\n      } as UnfollowChunkedFailureResult<Album>;\n    }\n  }\n};\n\nexport default unfollowAlbumsChunked;\n","import { PlaylistFollowsResponse, UserInfo } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserPlaylistFollows = async (user: UserInfo, limit: number, offset?: number) =>\n  await getJsonResponse<PlaylistFollowsResponse>(\n    await sendRequest([\"users\", user.id, \"playlists\"], {\n      limit,\n      offset,\n    }),\n  );\n\nexport default getUserPlaylistFollows;\n","import { isNullOrUndefined } from \"../../../util\";\nimport { FollowedPlaylistsList } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getCurrentUser from \"./get-current-user\";\nimport getUserPlaylistFollows from \"./get-user-playlist-follows\";\nconst getAllUserPlaylistFollows = async function* () {\n  const currentUser = await getCurrentUser();\n  let offset = undefined;\n\n  do {\n    const results: FollowedPlaylistsList = await getUserPlaylistFollows(currentUser, BATCH_SIZE, offset);\n    yield results.items.filter(({ owner: { id: playlistOwnerId } }) => playlistOwnerId !== currentUser.id);\n    // yield results.items;\n\n    offset = results.offset + results.limit;\n    if (offset >= results.total) {\n      offset = undefined;\n    }\n  } while (!isNullOrUndefined(offset));\n};\n\nexport default getAllUserPlaylistFollows;\n","import { Playlist } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowPlaylist = async (playlist: Playlist) =>\n  await sendRequest(\n    [\"playlists\", playlist.id, \"followers\"],\n    undefined,\n    null,\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowPlaylist;\n","import { Playlist, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport unfollowPlaylist from \"./unfollow-playlist\";\n\nconst unfollowPlaylistsChunked = async function* (playlists: Playlist[]) {\n  for (const playlist of playlists) {\n    try {\n      await unfollowPlaylist(playlist);\n      yield {\n        succeeded: [playlist],\n      } as UnfollowChunkedSuccessResult<Playlist>;\n    } catch (error) {\n      yield {\n        failed: [playlist],\n        error: error,\n      } as UnfollowChunkedFailureResult<Playlist>;\n    }\n  }\n};\n\nexport default unfollowPlaylistsChunked;\n","import { Dispatch, SetStateAction, useEffect, useMemo, useState } from \"react\";\nimport useCall from \"../../util/use-call\";\nimport useStreamCall from \"../../util/use-stream-call\";\nimport getAllUserArtistFollows from \"./api/get-all-user-artist-follows\";\nimport getAllUserShowFollows from \"./api/get-all-user-show-follows\";\nimport getCurrentUser from \"./api/get-current-user\";\nimport unfollowArtistsChunked from \"./api/unfollow-artists-chunked\";\nimport unfollowShowsChunked from \"./api/unfollow-shows-chunked\";\nimport unfollowUsersChunked from \"./api/unfollow-users-chunked\";\nimport {\n  Album,\n  Artist,\n  Follow,\n  FollowType,\n  FollowedUser,\n  Playlist,\n  Show,\n  UnfollowChunkedResult,\n  getResultTypesForFollowTypes,\n} from \"./model\";\nimport getAllUserAlbumFollows from \"./api/get-all-user-album-follows\";\nimport unfollowAlbumsChunked from \"./api/unfollow-albums-chunked\";\nimport getAllUserPlaylistFollows from \"./api/get-all-user-playlist-follows\";\nimport unfollowPlaylistsChunked from \"./api/unfollow-playliss-chunked\";\n\nexport const useGetCurrentUser = (runNow: boolean = true) => useCall(getCurrentUser, runNow);\n\nconst updateAllFollowsList = (\n  setAllFollows: Dispatch<SetStateAction<Follow[]>>,\n  newFollowsHandler: (...newFollows: Follow[]) => void,\n  followsChunked: Follow[][],\n) => {\n  if (followsChunked.length === 0) {\n    return;\n  }\n\n  const newFollows = followsChunked[followsChunked.length - 1];\n  setAllFollows((follows) => [...follows, ...newFollows]);\n\n  newFollowsHandler(...newFollows);\n};\n\nconst updateAllErrorsList = (setAllErrors: Dispatch<SetStateAction<Error[]>>, error?: Error) => {\n  if (!error) {\n    return;\n  }\n\n  setAllErrors((errors) => [...errors, error]);\n};\n\nexport const useGetAllUserArtistFollows = (\n  followTypes: FollowType[],\n  newFollowsHandler: (...newFollows: Follow[]) => void,\n  runNow = true,\n) => {\n  const [followedArtists, loadingArtists, artistsError] = useStreamCall(\n    getAllUserArtistFollows,\n    runNow && followTypes.includes(\"ARTIST\"),\n    \"artist\",\n  );\n  const [followedUsers, loadingUsers, usersError] = useStreamCall(\n    getAllUserArtistFollows,\n    runNow && followTypes.includes(\"USER\"),\n    \"user\",\n  );\n  const [followedShows, loadingShows, showsError] = useStreamCall(\n    getAllUserShowFollows,\n    runNow && followTypes.includes(\"SHOW\"),\n  );\n  const [followedAlbums, loadingAlbums, albumError] = useStreamCall(\n    getAllUserAlbumFollows,\n    runNow && followTypes.includes(\"ALBUM\"),\n  );\n  const [followedPlaylists, loadingPlaylists, playlistError] = useStreamCall(\n    getAllUserPlaylistFollows,\n    runNow && followTypes.includes(\"PLAYLIST\"),\n  );\n\n  const [allFollows, setAllFollows] = useState<Follow[]>([]);\n\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedArtists),\n    [followedArtists, newFollowsHandler, setAllFollows],\n  );\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedUsers),\n    [followedUsers, newFollowsHandler, setAllFollows],\n  );\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedShows),\n    [followedShows, newFollowsHandler, setAllFollows],\n  );\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedAlbums),\n    [followedAlbums, newFollowsHandler, setAllFollows],\n  );\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedPlaylists),\n    [followedPlaylists, newFollowsHandler, setAllFollows],\n  );\n\n  const [allErrors, setAllErrors] = useState<Error[]>([]);\n\n  useEffect(() => updateAllErrorsList(setAllErrors, artistsError), [artistsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, usersError), [usersError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, showsError), [showsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, albumError), [albumError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, playlistError), [playlistError, setAllErrors]);\n\n  useEffect(() => {\n    const resultTypes = getResultTypesForFollowTypes(...followTypes);\n    setAllFollows((follows) => follows.filter(({ type }) => resultTypes.includes(type)));\n  }, [followTypes, setAllFollows, setAllErrors]);\n\n  return [\n    allFollows,\n    loadingArtists || loadingUsers || loadingShows || loadingAlbums || loadingPlaylists,\n    allErrors,\n  ] as [Follow[], boolean, Error[]];\n};\n\nconst updateAllUnfollowsList = (\n  setAllUnfollows: Dispatch<SetStateAction<UnfollowChunkedResult<Follow>[]>>,\n  newUnfollowsHandler: (newUnfollows: UnfollowChunkedResult<Follow>) => void,\n  unfollowsChunked: UnfollowChunkedResult<Follow>[],\n) => {\n  if (unfollowsChunked.length === 0) {\n    return;\n  }\n\n  const newUnfollows = unfollowsChunked[unfollowsChunked.length - 1];\n  setAllUnfollows((unfollows) => [...unfollows, newUnfollows]);\n\n  newUnfollowsHandler(newUnfollows);\n};\n\nexport const useUnfollowFollowsChunked = (\n  follows: Follow[],\n  newUnfollowsHandler: (newUnfollows: UnfollowChunkedResult<Follow>) => void,\n  runNow: boolean = true,\n) => {\n  const followedArtists = useMemo(\n    () => follows.filter((follow): follow is Artist => follow.type === \"artist\"),\n    [follows],\n  );\n  const followedUsers = useMemo(\n    () => follows.filter((follow): follow is FollowedUser => follow.type === \"user\"),\n    [follows],\n  );\n  const followedShows = useMemo(() => follows.filter((follow): follow is Show => follow.type === \"show\"), [follows]);\n  const followedAlbums = useMemo(() => follows.filter((follow): follow is Album => follow.type === \"album\"), [follows]);\n  const followedPlaylists = useMemo(\n    () => follows.filter((follow): follow is Playlist => follow.type === \"playlist\"),\n    [follows],\n  );\n\n  const [unfollowArtists, loadingArtists, artistsError] = useStreamCall(\n    unfollowArtistsChunked,\n    runNow,\n    followedArtists,\n  );\n  const [unfollowUsers, loadingUsers, usersError] = useStreamCall(unfollowUsersChunked, runNow, followedUsers);\n  const [unfollowShows, loadingShows, showsError] = useStreamCall(unfollowShowsChunked, runNow, followedShows);\n  const [unfollowAlbums, loadingAlbums, albumsError] = useStreamCall(unfollowAlbumsChunked, runNow, followedAlbums);\n  const [unfollowPlaylists, loadingPlaylists, playlistsError] = useStreamCall(\n    unfollowPlaylistsChunked,\n    runNow,\n    followedPlaylists,\n  );\n\n  const [allUnfollows, setAllUnfollows] = useState<UnfollowChunkedResult<Follow>[]>([]);\n\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowArtists),\n    [unfollowArtists, newUnfollowsHandler, setAllUnfollows],\n  );\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowUsers),\n    [unfollowUsers, newUnfollowsHandler, setAllUnfollows],\n  );\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowShows),\n    [unfollowShows, newUnfollowsHandler, setAllUnfollows],\n  );\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowAlbums),\n    [unfollowAlbums, newUnfollowsHandler, setAllUnfollows],\n  );\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowPlaylists),\n    [unfollowPlaylists, newUnfollowsHandler, setAllUnfollows],\n  );\n\n  const [allErrors, setAllErrors] = useState<Error[]>([]);\n\n  useEffect(() => updateAllErrorsList(setAllErrors, artistsError), [artistsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, usersError), [usersError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, showsError), [showsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, albumsError), [albumsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, playlistsError), [playlistsError, setAllErrors]);\n\n  return [\n    allUnfollows,\n    loadingArtists || loadingUsers || loadingShows || loadingAlbums || loadingPlaylists,\n    allErrors,\n  ] as [UnfollowChunkedResult<Follow>[], boolean, Error[]];\n};\n","import \"./UserInfo.css\";\n\nimport { useGetCurrentUser } from \"../../../client/spotify\";\n\nconst UserInfo = (): JSX.Element => {\n  const [user, loading, error] = useGetCurrentUser();\n\n  return (\n    <div className=\"user\">\n      {error ? (\n        <div className=\"error\">Error retrieving user info: {error.message}</div>\n      ) : loading ? (\n        <div className=\"warning\">Retrieving user info</div>\n      ) : user ? (\n        <div className=\"info\">\n          Logged in as: <strong>{user.id}</strong>\n        </div>\n      ) : (\n        <div className=\"error\">Not logged in</div>\n      )}\n    </div>\n  );\n};\n\nexport default UserInfo;\n"],"names":["isNullOrUndefined","value","undefined","apiCall","runNow","_len","arguments","length","apiArguments","Array","_key","result","setResult","useState","error","setError","loading","setLoading","useEffect","abort","callResult","errorObj","name","newResult","oldResult","getJsonResponse","response","json","FetchError","Error","constructor","status","body","headers","super","_status","_body","_headers","this","handleFetchResponse","async","resolve","reject","countInfo","url","requestContext","retryableErrorCodes","ok","attemptCount","maxAttemptCount","isRetryableCode","performFetch","message","priorResponse","setTimeout","fetch","getNextRetryTime","nextRetryTime","get","Math","max","pow","Number","code","indexOf","Promise","pathParams","queryParams","method","requestPath","SPOTIFY_API_URL","join","queryPath","queryObj","Object","keys","filter","queryKey","map","encodeURIComponent","retryFetch","createRequestContext","Authorization","config","userToken","catch","resetToken","type","limit","after","results","sendRequest","artists","users","isUserInfo","item","getUserArtistFollows","BATCH_SIZE","items","display_name","cursors","offset","getUserShowFollows","_ref","show","total","arrayChunk","array","size","chunks","i","push","slice","min","ids","artist","id","chunkedArtists","unfollowArtists","succeeded","failed","shows","chunkedShows","unfollowShows","user","chunkedUsers","unfollowUsers","getUserAlbumFollows","album","albums","chunkedAlbums","unfollowAlbums","currentUser","getCurrentUser","getUserPlaylistFollows","owner","playlistOwnerId","playlist","playlists","unfollowPlaylist","useGetCurrentUser","useCall","updateAllFollowsList","setAllFollows","newFollowsHandler","followsChunked","newFollows","follows","updateAllErrorsList","setAllErrors","errors","useGetAllUserArtistFollows","followTypes","followedArtists","loadingArtists","artistsError","useStreamCall","getAllUserArtistFollows","includes","followedUsers","loadingUsers","usersError","followedShows","loadingShows","showsError","getAllUserShowFollows","followedAlbums","loadingAlbums","albumError","getAllUserAlbumFollows","followedPlaylists","loadingPlaylists","playlistError","getAllUserPlaylistFollows","allFollows","allErrors","resultTypes","getResultTypesForFollowTypes","updateAllUnfollowsList","setAllUnfollows","newUnfollowsHandler","unfollowsChunked","newUnfollows","unfollows","useUnfollowFollowsChunked","useMemo","follow","unfollowArtistsChunked","unfollowUsersChunked","unfollowShowsChunked","albumsError","unfollowAlbumsChunked","unfollowPlaylists","playlistsError","unfollowPlaylistsChunked","allUnfollows","UserInfo","_jsx","className","children","_jsxs"],"sourceRoot":""}